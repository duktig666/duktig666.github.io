(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{588:function(v,_,t){"use strict";t.r(_);var o=t(3),r=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"远程调用的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#远程调用的流程"}},[v._v("#")]),v._v(" 远程调用的流程")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typecho-1300745270.cos.ap-shanghai.myqcloud.com/typora/202201151957953.png",alt:"img"}})]),v._v(" "),_("p",[v._v("生产者端流程：")]),v._v(" "),_("ol",[_("li",[v._v("加载服务接口，并缓存")]),v._v(" "),_("li",[v._v("服务注册，将服务接口以及服务主机信息写入注册中心（本例使用的是 zookeeper)")]),v._v(" "),_("li",[v._v("启动网络服务器并监听")]),v._v(" "),_("li",[v._v("反射，本地调用")])]),v._v(" "),_("p",[v._v("消费者端流程：")]),v._v(" "),_("ol",[_("li",[v._v("代理服务接口生成代理对象")]),v._v(" "),_("li",[v._v("服务发现（连接 zookeeper，拿到服务地址列表，通过客户端负载策略获取合适的服务地址）")]),v._v(" "),_("li",[v._v("远程方法调用（本例通过 Netty，发送消息，并获取响应结果）")])]),v._v(" "),_("h2",{attrs:{id:"实现一个rpc框架需要考虑哪些因素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现一个rpc框架需要考虑哪些因素"}},[v._v("#")]),v._v(" 实现一个RPC框架需要考虑哪些因素？")]),v._v(" "),_("p",[_("strong",[v._v("1、注册中心")])]),v._v(" "),_("p",[v._v("各个服务需要注册到注册中心，注册中心统一管理服务列表，远程调用时通过服务发现机制去获取目标服务的地址。")]),v._v(" "),_("p",[v._v("调用方需要将注册中心的服务地址进行缓存。")]),v._v(" "),_("p",[v._v("注册中心的服务地址发生变更需要通知客户端。")]),v._v(" "),_("p",[_("strong",[v._v("2、网络通信")])]),v._v(" "),_("p",[v._v("网络通信涉及 "),_("strong",[v._v("序列化、反序列化以及编解码")]),v._v("，服务调用时进行参数传递，可采用高效的json序列化方式。")]),v._v(" "),_("p",[v._v("网络通信框架可采用 Netty")]),v._v(" "),_("p",[v._v("通信协议根据需要进行选择")]),v._v(" "),_("p",[_("strong",[v._v("3、负载均衡策略")])]),v._v(" "),_("p",[v._v("一般来说，每个服务有多个实例，远程调用时获取生产者地址时，要有一定的负载均衡策略，常用的有 随机、轮询等策略。")]),v._v(" "),_("p",[_("strong",[v._v("4、动态代理")])]),v._v(" "),_("p",[v._v("例如 Dubbo 提供的是"),_("code",[v._v("基于接口的远程方法调用")]),v._v("，即客户端只需要知道接口的定义即可调用远程服务。在 Java 中接口并不能直接调用实例方法，必须通过其实现类对象来完成此操作，这意味着客户端必须为这些接口生成"),_("code",[v._v("代理对象")]),v._v("，对此 Java 提供了 "),_("code",[v._v("Proxy")]),v._v("、"),_("code",[v._v("InvocationHandler")]),v._v(" 生成动态代理的支持；生成了代理对象，那么每个具体的发方法是怎么调用的呢？jdk 动态代理生成的代理对象调用指定方法时实际会执行 "),_("code",[v._v("InvocationHandler")]),v._v(" 中定义的 "),_("code",[v._v("#invoke")]),v._v(" 方法，在该方法中完成远程方法调用并获取结果。")]),v._v(" "),_("p",[_("strong",[v._v("5、失败重试机制")])]),v._v(" "),_("p",[v._v("一次远程调用不一定成功，可能存在网络等问题，导致调用失败。")]),v._v(" "),_("p",[v._v("调用失败后，一般不能直接返回失败，在 "),_("strong",[v._v("一定的时间/次数内")]),v._v(" 进行失败重试。")]),v._v(" "),_("p",[_("strong",[v._v("6、限流/熔断")])]),v._v(" "),_("p",[v._v("服务间的调用也要有一定的限流和熔断策略，来保证服务的可靠性。")]),v._v(" "),_("h2",{attrs:{id:"参看"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参看"}},[v._v("#")]),v._v(" 参看")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://xiaomi-info.github.io/2020/03/02/rpc-achieve/",target:"_blank",rel:"noopener noreferrer"}},[v._v("浅析 RPC 与基本实现"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=r.exports}}]);